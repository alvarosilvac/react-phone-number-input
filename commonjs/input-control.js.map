{"version":3,"sources":["../source/input-control.js"],"names":["getPreSelectedCountry","getCountrySelectOptions","parsePhoneNumberCharacter","parsePhoneNumberCharacters","formatPhoneNumber","parsePhoneNumber","generateNationalNumberDigits","migrateParsedInputForNewCountry","e164","getCountryForParsedInput","get_country_from_possibly_incomplete_international_phone_number","compare_strings","has_international_option","strip_country_calling_code","get_national_significant_number_part","could_number_belong_to_country","parsed_number","country","countries","includeInternationalOption","metadata","_countries","country_names","country_select_options","map","value","label","sort","a","b","unshift","ZZ","character","string","result","split","formatter","text","input","template","parsed_phone","replace","previous_country","new_country","partial_national_significant_number","number","parsed_input","derived_country","indexOf","undefined","String","prototype","localeCompare","length","country_calling_prefix","slice","Object","keys","country_calling_codes","country_calling_code","getNationalNumber","i"],"mappings":"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","file":"input-control.js","sourcesContent":["import\n{\n\tparseNumber,\n\tformatNumber,\n\tgetCountryCallingCode,\n\tAsYouType\n}\nfrom 'libphonenumber-js/custom'\n\nimport { parseDigit } from 'input-format'\n\nimport default_country_names, { countries } from './countries'\n\n/**\n * Decides which country should be pre-selected\n * when the phone number input component is first mounted.\n * @param  {object} parsedNumber - A parsed number object: `{ country, phone }`. Can be an empty object.\n * @param  {string?} country - Pre-defined country (two-letter code).\n * @param  {string[]} countries - A list of countries available.\n * @param  {boolean} includeInternationalOption - Whether \"International\" country option is available.\n * @param  {object} metadata - `libphonenumber-js` metadata\n * @return {string?}\n */\nexport function getPreSelectedCountry(parsed_number, country, countries, includeInternationalOption, metadata)\n{\n\t// If can get country from E.164 phone number\n\t// then it overrides the `country` passed (or not passed).\n\tif (parsed_number.country)\n\t{\n\t\t// `country` will be left `undefined` in case of non-detection.\n\t\tcountry = parsed_number.country\n\t}\n\n\t// If there will be no \"International\" option\n\t// then some `country` must be selected.\n\t// It will still be the wrong country though.\n\t// But still country `<select/>` can't be left in a broken state.\n\tif (!country && !has_international_option(countries, includeInternationalOption))\n\t{\n\t\tcountry = countries[0]\n\t}\n\n\treturn country\n}\n\n/**\n * Generates a sorted list of country `<select/>` options.\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\n * @param  {object?} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\n * @param  {boolean} includeInternationalOption - Whether should include \"International\" option at the top of the list.\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\n */\nexport function getCountrySelectOptions(_countries, country_names, includeInternationalOption)\n{\n\t// Generates a `<Select/>` option for each country.\n\tconst country_select_options = _countries.map((country) =>\n\t({\n\t\tvalue : country,\n\t\tlabel : (country_names && country_names[country]) || default_country_names[country]\n\t}))\n\n\t// Sort the list of countries alphabetically.\n\t//\n\t// This is only done when custom `countries` are supplied.\n\t//\n\t// If no custom `countries` are supplied\n\t// then this means the default list of `countries`\n\t// is used which is already sorted by country name alphabetically.\n\t//\n\tif (_countries !== countries || country_names)\n\t{\n\t\tcountry_select_options.sort((a, b) => compare_strings(a.label, b.label))\n\t}\n\n\t// Add the \"International\" option to the country list (if suitable)\n\tif (has_international_option(_countries, includeInternationalOption))\n\t{\n\t\tcountry_select_options.unshift\n\t\t({\n\t\t\tlabel : (country_names && country_names.ZZ) || default_country_names.ZZ\n\t\t})\n\t}\n\n\treturn country_select_options\n}\n\n/**\n * `input-format` `parse()` function.\n * https://github.com/catamphetamine/input-format\n * @param  {string} character - Yet another character from raw input string.\n * @param  {string} value - The value parsed so far.\n * @param  {object} meta - Optional custom use-case-specific metadata.\n * @return {string?} The parsed character.\n */\nexport function parsePhoneNumberCharacter(character, value)\n{\n\t// Only allow a leading `+`.\n\tif (character === '+')\n\t{\n\t\t// If this `+` is not the first parsed character\n\t\t// then discard it.\n\t\tif (value) {\n\t\t\treturn\n\t\t}\n\n\t\treturn '+'\n\t}\n\n\t// Allow digits.\n\treturn parseDigit(character)\n}\n\n/**\n * Parses phone number characters from a string.\n * @param  {string} string\n * @return {string}\n * @example\n * ```js\n * parsePhoneNumberCharacters('8 (800) 555')\n * // Outputs '8800555'.\n * parsePhoneNumberCharacters('+7 800 555')\n * // Outputs '+7800555'.\n * ```\n */\nexport function parsePhoneNumberCharacters(string)\n{\n\tlet result = ''\n\n\t// Using `.split('')` here instead of normal `for ... of`\n\t// because the importing application doesn't neccessarily include an ES6 polyfill.\n\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\n\t// (the ones consisting of four bytes) but digits\n\t// (including non-European ones) don't fall into that range\n\t// so such \"exotic\" characters would be discarded anyway.\n\tfor (const character of string.split(''))\n\t{\n\t\tresult += parsePhoneNumberCharacter(character, result) || ''\n\t}\n\n\treturn result\n}\n\n/**\n * Formats a (possibly incomplete) phone number.\n * The phone number can be either in E.164 format\n * or in a form of national number digits.\n * Is used for `input-format`'s `format()` function.\n * https://github.com/catamphetamine/input-format\n * @param {string} value - A possibly incomplete phone number. Either in E.164 format or in a form of national number digits.\n * @param {string?} country - Two-letter (\"ISO 3166-1 alpha-2\") country code.\n * @return {object} `{ text : string, template : string }`\n */\nexport function formatPhoneNumber(value, country, metadata)\n{\n\t// \"As you type\" formatter.\n\tconst formatter = new AsYouType(country, metadata)\n\n\t// Format the number.\n\tconst text = formatter.input(value)\n\n\treturn { text, template: formatter.template }\n}\n\n/**\n * Parses a E.164 phone number to an object having shape `{ country : string, phone : string }`.\n * @param {string} value = E.164 phone number.\n * @param  {object} metadata - `libphonenumber-js` metadata\n * @example\n * parsePhoneNumber('+78005553535')\n * // returns `{ country: 'RU', phone: '8005553535' }`\n */\nexport function parsePhoneNumber(value, metadata)\n{\n\treturn parseNumber(value || '', metadata)\n}\n\n/**\n * Generates national number digits for a parsed phone.\n * May prepend national prefix.\n * @param  {object} parsedPhone - Object having shape `{ country : string, phone : string }`.\n * @param  {object} metadata - `libphonenumber-js` metadata\n * @return {string}\n * @example\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\n * // returns '88005553535'\n */\nexport function generateNationalNumberDigits(parsed_phone, metadata)\n{\n\treturn formatNumber(parsed_phone, 'National', metadata).replace(/\\D/g, '')\n}\n\n/**\n * Migrates `<input/>` parsed `value` for the newly selected `country`.\n * @param {string?} value - The `value` parsed from phone number `<input/>` (it's the `parsed_input` state property, not the `value` property).\n * @param {string?} previousCountry - Previously selected country.\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\n * @param {object} metadata - `libphonenumber-js` metadata.\n * @return {string}\n */\nexport function migrateParsedInputForNewCountry\n(\n\tvalue,\n\tprevious_country,\n\tnew_country,\n\tmetadata\n)\n{\n\t// If `parsed_input` is empty\n\t// then no need to migrate anything.\n\tif (!value) {\n\t\treturn value\n\t}\n\n\t// If switching to some country.\n\t// (from \"International\" or another country)\n\t// If switching from \"International\" then `value` starts with a `+`.\n\t// Otherwise it may or may not start with a `+`.\n\tif (new_country)\n\t{\n\t\t// If the phone number was entered in international format\n\t\t// then migrate it to the newly selected country.\n\t\t// The phone number may be incomplete.\n\t\t// The phone number entered not necessarily starts with\n\t\t// the previously selected country phone prefix.\n\t\tif (value[0] === '+')\n\t\t{\n\t\t\t// If the international phone number already contains\n\t\t\t// any country calling code then trim the country calling code part.\n\t\t\t// (that could also be the newly selected country phone code prefix as well)\n\t\t\t// `value` doesn't neccessarily belong to `previous_country`.\n\t\t\t// (e.g. if a user enters an international number\n\t\t\t//  not belonging to any of the reduced `countries` list)\n\t\t\tvalue = strip_country_calling_code(value, previous_country, metadata)\n\n\t\t\t// Prepend country calling code prefix\n\t\t\t// for the newly selected country.\n\t\t\treturn `+${getCountryCallingCode(new_country, metadata)}${value}`\n\t\t}\n\t}\n\t// If switching to \"International\" from a country.\n\telse\n\t{\n\t\t// If the phone number was entered in national format.\n\t\tif (value[0] !== '+')\n\t\t{\n\t\t\t// Format the national phone number as an international one.\n\t\t\t// The phone number entered not necessarily even starts with\n\t\t\t// the previously selected country phone prefix.\n\t\t\t// Even if the phone number belongs to whole another country\n\t\t\t// it will still be parsed into some national phone number.\n\t\t\tconst partial_national_significant_number = get_national_significant_number_part(value, previous_country, metadata)\n\t\t\treturn formatNumber(partial_national_significant_number, previous_country, 'E.164', metadata)\n\t\t}\n\t}\n\n\treturn value\n}\n\n/**\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\n * @param  {string?} country\n * @param  {[object} metadata - `libphonenumber-js` metadata.\n * @return {string?}\n */\nexport function e164(number, country, metadata)\n{\n\tif (!number) {\n\t\treturn\n\t}\n\n\t// If the phone number is being input in international format.\n\tif (number[0] === '+')\n\t{\n\t\t// If it's just the `+` sign then return nothing.\n\t\tif (number === '+') {\n\t\t\treturn\n\t\t}\n\n\t\t// If there are any digits then the `value` is returned as is.\n\t\treturn number\n\t}\n\n\t// For non-international phone numbers\n\t// an accompanying country code is required.\n\tif (!country) {\n\t\treturn\n\t}\n\n\tconst partial_national_significant_number = get_national_significant_number_part(number, country, metadata)\n\n\tif (!partial_national_significant_number) {\n\t\treturn\n\t}\n\n\treturn formatNumber(partial_national_significant_number, country, 'E.164', metadata)\n}\n\n// If the phone number being input is an international one\n// then tries to derive the country from the phone number.\n// (regardless of whether there's any country currently selected)\n/**\n * @param {string} parsedInput - A possibly incomplete E.164 phone number.\n * @param {string?} country - Currently selected country.\n * @param {string[]} countries - A list of available countries.\n * @param {boolean} includeInternationalOption - Whether \"International\" country option is available.\n * @param  {[object} metadata - `libphonenumber-js` metadata.\n * @return {string?}\n */\nexport function getCountryForParsedInput\n(\n\tparsed_input,\n\tcountry,\n\tcountries,\n\tincludeInternationalOption,\n\tmetadata\n)\n{\n\tif (parsed_input === '+')\n\t{\n\t\t// Don't change the currently selected country yet.\n\t\treturn country\n\t}\n\n\tconst derived_country = get_country_from_possibly_incomplete_international_phone_number(parsed_input, metadata)\n\n\t// If a phone number is being input in international form\n\t// and the country can already be derived from it,\n\t// then select that country.\n\tif (derived_country && countries.indexOf(derived_country) >= 0)\n\t{\n\t\treturn derived_country\n\t}\n\t// If \"International\" country option has not been disabled\n\t// and the international phone number entered doesn't correspond\n\t// to the currently selected country then reset the currently selected country.\n\telse if (country &&\n\t\thas_international_option(countries, includeInternationalOption) &&\n\t\t!could_number_belong_to_country(parsed_input, country, metadata))\n\t{\n\t\treturn undefined\n\t}\n\n\t// Don't change the currently selected country.\n\treturn country\n}\n\n/**\n * Determines the country for a given (possibly incomplete) E.164 phone number.\n * @param  {string} number - A possibly incomplete E.164 phone number.\n * @param  {object} metadata - `libphonenumber-js` metadata.\n * @return {string?}\n */\nexport function get_country_from_possibly_incomplete_international_phone_number(number, metadata)\n{\n\tconst formatter = new AsYouType(null, metadata)\n\tformatter.input(number)\n\t// `001` is a special \"non-geograpical entity\" code\n\t// in Google's `libphonenumber` library.\n\tif (formatter.country === '001') {\n\t\treturn\n\t}\n\treturn formatter.country\n}\n\n/**\n * Compares two strings.\n * A helper for `Array.sort()`.\n */\nexport function compare_strings(a, b) {\n  // Use `String.localeCompare` if it's available.\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n  // Which means everyone except IE <= 10 and Safari <= 10.\n  if (String.prototype.localeCompare) {\n    return a.localeCompare(b);\n  }\n  return a < b ? -1 : (a > b ? 1 : 0);\n}\n\n/**\n * Whether should add the \"International\" option to country `<select/>`.\n */\nexport function has_international_option(_countries, includeInternationalOption)\n{\n\t// If this behaviour is explicitly set, then do as it says.\n\tif (includeInternationalOption !== undefined)\n\t{\n\t\treturn includeInternationalOption\n\t}\n\n\t// If the list of `countries` has been overridden\n\t// then only show \"International\" option\n\t// if no countries have been left out.\n\t// The reasoning is that if some countries were left out\n\t// and a user selects \"International\" option\n\t// then he can input a phone number for a non-included country\n\t// and perhaps that's what a developer didn't encourage\n\t// when he was reducing the set of selectable countries.\n\treturn _countries.length >= countries.length\n}\n\n/**\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\n * @param {string} number - (possibly incomplete) E.164 phone number.\n * @param {string?} country - A possible country for this phone number.\n * @param {object} metadata - `libphonenumber-js` metadata.\n * @return {string}\n */\nexport function strip_country_calling_code(number, country, metadata)\n{\n\t// Just an optimization, so that it\n\t// doesn't have to iterate through all country calling codes.\n\tif (country)\n\t{\n\t\tconst country_calling_prefix = '+' + getCountryCallingCode(country, metadata)\n\n\t\t// If `country` fits the actual `number`.\n\t\tif (number.length < country_calling_prefix.length)\n\t\t{\n\t\t\tif (country_calling_prefix.indexOf(number) === 0)\n\t\t\t{\n\t\t\t\treturn ''\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (number.indexOf(country_calling_prefix) === 0)\n\t\t\t{\n\t\t\t\treturn number.slice(country_calling_prefix.length)\n\t\t\t}\n\t\t}\n\t}\n\n\t// If `country` doesn't fit the actual `number`.\n\t// Try all available country calling codes.\n\tfor (const country_calling_code of Object.keys(metadata.country_calling_codes))\n\t{\n\t\tif (number.indexOf(country_calling_code) === '+'.length)\n\t\t{\n\t\t\treturn number.slice('+'.length + country_calling_code.length)\n\t\t}\n\t}\n\n\treturn ''\n}\n\n/**\n * Parses a partially entered national phone number digits\n * (or a partially entered E.164 international phone number)\n * and returns the national significant number part.\n * National significant number returned doesn't come with a national prefix.\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\n * @param {string?} country\n * @param {object} metadata - `libphonenumber-js` metadata.\n */\nexport function get_national_significant_number_part(number, country, metadata)\n{\n\t// Create \"as you type\" formatter.\n\tconst formatter = new AsYouType(country, metadata)\n\n\t// Input partial national phone number.\n\tformatter.input(number)\n\n\t// Return the parsed partial national phone number.\n\treturn formatter.getNationalNumber()\n}\n\n/**\n * Checks if a partially entered E.164 phone number could belong to a country.\n * @param  {string} number\n * @param  {string} country\n * @return {boolean}\n */\nexport function could_number_belong_to_country(number, country, metadata)\n{\n\tconst country_calling_code = getCountryCallingCode(country, metadata)\n\n\tlet i = 0\n\twhile (i + 1 < number.length && i < country_calling_code.length)\n\t{\n\t\tif (number[i + 1] !== country_calling_code[i])\n\t\t{\n\t\t\treturn false\n\t\t}\n\t\ti++\n\t}\n\n\treturn true\n}"]}